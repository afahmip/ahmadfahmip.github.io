<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Slide Linux</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<style>
			#open-menu {
				color: #00a5c2;
				margin-left: 3vw;
				margin-top: 3vh;
				font-family: 'Segoe UI';
				position: absolute;
				font-size: 0.5em;
				cursor:pointer;
				z-index: 100;
			}

			.overlay-menu {
				font-family: 'Segoe UI';
				height: 100%;
				width: 0;
				position: fixed;
				z-index: 1000;
				top: 0;
				left: 0;
				background-color: rgb(0,0,0);
				background-color: rgba(0,0,0, 0.9);
				overflow-x: hidden;
				transition: 0.5s;
			}

			.overlay-menu-content {
				position: relative;
				top: 15%;
				width: 100%;
				text-align: center;
				margin-top: 30px;
			}

			.overlay-menu a {
				padding: 8px;
				text-decoration: none;
				font-size: 2em;
				color: #818181;
				display: block;
				transition: 0.3s;
			}

			.overlay-menu a:hover, .overlay-menu a:focus {
				color: #f1f1f1;
			}

			.overlay-menu .closebtn {
				position: absolute;
				top: 20px;
				right: 45px;
				font-size: 60px;
			}

			@media screen and (max-height: 450px) {
				.overlay-menu a {font-size: 20px}
				.overlay-menu .closebtn {
					font-size: 40px;
					top: 15px;
					right: 35px;
				}
			}
		</style>
	</head>
	<body>
		<div class="reveal">
			<span id="open-menu" onclick="openNav()">&#9776; Navigate</span>
			<!-- <button id="open-menu" onclick="openNav()">Navigate</button> -->
			<div class="slides">
				<section style="text-align: left" data-background="#f7f7f7">
					<h1 style="color: #ffbf00">Kitab Linux</h1>
					<h4 style="font-size: 0.75em; color: #5b5b5b">Oleh: Sammy, Joseph, Fahmi, Gery, Tanor, Ody, Hagai, Eka</h4>
					<!-- <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/35/Tux.svg/2000px-Tux.svg.png" alt=""> -->
				</section>
				<!-- Sejarah Linux -->
				<section>
					<section data-background="#fcfcfc">
						<h1>Sejarah Linux</h1>
						<p style="color: #008299">Sebuah kisah yang mengubah umat manusia</p>
					</section>
					<section>
						<img src="https://img.memecdn.com/linus-torvalds-the-good-linux-creator_o_3334599.jpg" alt="">
					</section>
					<section data-background="#bfbfbf">
						<p>Pada awal mula, setelah Bell Labs cabut dari development mutex, 
							Ken Thompson menciptakan UNIX dan Dennis Richie menciptakan bahasa C. 
							Bell Labs adalah anak perusahan dari, tapi karena hukum monopoli sehingga 
							perusahaan tersebut dipecah dan banyak asetnya dipindahkan kemana mana.</p>
					</section>
					<section data-background="#848484">
						<p>Beberapa vendor yang memiliki lisensi UNIX membuat implementasinya sendiri, 
							beserta beberapa universitas dengan mahasiswanya masing - masing. AT&T melarang 
							penggunaan UNIX untuk menjadi bahan pembelajaran di Universitas yang tidak memiliki 
							lisensi UNIX. System yang merupakan standar dari UNIX di dunia, turunannya seperti IBM EIX, Sans Solaris, HP-UX.</p>
					</section>
					<section data-background="#4f4f4f">
						<p>Sementara itu, University of California, Berkeley, mahasiswanya membuat banyak modifikasi
							 pada UNIX yaitu BSD hingga versi 4. Pada tahun 90-an, muncul pertanyaan siapa yang memiiki 
							 hak cipta terhadap UNIX, dan Berkeley tidak mampu mendistribusikan BSD karena memiliki 
							 sebagian code UNIX. Lalu Berkeley mendistribusikan BSD yang pure tanpa code UNIX.</p>
					</section>
				</section>
				<!-- Design Principles -->
				<section data-background="#f7f7f7">
					<section>
						<h1>Design Principles</h1>
					</section>
					<section style="font-size: 0.7em; text-align: left">
						<h4>Kernel</h4>
						<p>kernel melakukan berbagai abstraksi dari sebuah sistem operasi, seperti : Signal, System calls, Process dan Sheduler, 
							Virtual Memory, File systems, Network protocols, Character Device Drivers, Block Device Drivers, Network Device Drivers, Trap dan Faults, Physical Memory, Interrupts.</p>
					</section>
					<section style="font-size: 0.7em; text-align: left">
						<h4>System Libraries</h4>
						<p>merupakan kumpulan fungsi-fungsi standar yang dipakai oleh aplikasi untuk dapat berinteraksi dengan kernel. Fungsi - fungsi ini mengimplemen fungsionalitas
							 yang tidak membutuhkan privilage penuh dari kernel code. Library yang paling penting : C library (libc). System libraries memberikan berbagai fungsionalitas,
							  baik dari syscall yang paling basic hingga kompleks, seperti menjalankan syscall untuk mentransfer kontrol dari user mode ke kernel mode, file handling,
							   algoritma sorting, fungsi matematis, manipulasi string.</p>
					</section>
					<section style="font-size: 0.7em; text-align: left">
						<h4>System Utilities</h4>
						<p>program yang menjalankan tugas khusus secara tersendiri. Beberapa utilitas dijalankan sekali saja dan kemudian melakukan konfigurasi beberapa aspek pada sistem. 
							Yg lainnya, yaitu daemons dijalankan secara permanen : contoh, <b>menerima koneksi (http daemon, ftp, ssh, telnet, bisa juga service, dkk) serta menerima logon requests, 
							mengupdate log file</b>, dan masih banyak lagi. Salah satu system utilities yang paling penting yaitu Shell, sebagai standard command line interface untuk UNIX. 
							Kebanyakan linux pakai BASH (Bourne Again Shell). Ada jg shell yang lain sepert ZSH, yaitu Z shell. Shell dipakai untuk menerima inputan dari user dan kemudian menjalankan perintah yang diminta. </p>
					</section>
					<section style="font-size: 0.8em">
						<h3>Kernel vs User</h3>
						<p>Kode pada kernel dapat mengeksekusi semua intruksi pada prosesor secara penuh. Kernel dapat mengakses physical resource ( hardware, driver, dkk) pada komputer.  
							Pada Linux, disebut sebagai kernel mode. Di sini, tidak ada user code yang dimasukan dan dibangun.</p>
						<p>Setiap kode yang tidak dibutuhkan untuk jalan di kernel mode diletakkan pada system libraries dan hanya berjalan di dalam user mode. 
							User mode hanya dapat mengakses ke beberapa bagian pada system resources yang sudah dicontrol.</p>
					</section>
					<section>
						<div style="display: flex;">
							<h3>Model Linux&nbsp;&nbsp;</h3>
							<h3 style="color: aqua" class="fragment">Monolithic + Modular</h3>
						</div>
						<div style="font-size: 0.6em; text-align: left" class="fragment">
							<p>Model linux menggunakan model monolitik dimana pada model ini setiap kode kernel dan struktur datanya diletakkan pada satu alamat memori yang sama 
							(core scheduling, virtual memory, device drivers, file systems, dan networking code). Dengan demikian, model ini meningkatkan dan design yang dibuat simpel dan mudah dimengerti. 
							Performance lebih bagus karena tidak memerlukan context switch (environment eksekusi) yaitu perpindahan antara proses (tidak perlu memerlukan page table, dlsb.) 
							ketika suatu proses tersebut memanggil fungsi kernel atau ketika interrupt hardware dilakukan. </p>
							<p>Walaupun semua komponen kernel diletakkan pada satu file kernel, masih ada ruang dalam modularity . Aplikasi user dapat me-load shared libraries modules secara dinamik pada saat run time. 
								Module ini benar-benar independen terhadap kernel dan disebut loadable module dan mempunyai dua karakteristik penting :</p>
							<p class="fragment"><b>Dynamic Linking</b> -> bisa diload dan di keluarkan dari memory kapan saja</p>
							<p class="fragment"><b>Stackable Module</b> -> sistem hirearkis, user paling atas</p>
						</div>
					</section>
					<section>
						<p style="font-size: 0.75em">Salah satu perintah untuk menambahkan kernel module yaitu dengan perintah insmod -> insmod can insert a single module from any location, 
							and does not consider dependencies when doing so. It's a much lower-level program. </p>
						<p class="fragment" style="font-size: 0.75em">Syntax : insmod [file name] [module-options...]</p>
						<div class="fragment" data-markdown>
							<script type="text/template">
								```

								insmod /path/to/snd-usb-audio.ko snd-cmipci snd_id="first" snd_mpu_port=0x330

								```
							</script>
						</div>
						<p class="fragment" style="font-size: 0.75em">Buat mengecek module yang ada dilakukan dengan perintah lsmod</p>
					</section>
					<section>
							Setiap module didefined oleh 2 tabel : module table dan symbol table. 
							The module table includes the following elements:
							• *next: Pointer to the following module. All modules are organized into a linked list. The
							list begins with a pseudomodule (not shown in Figure 2.17).
							• *name: Pointer to module name.
							• size: Module size in memory pages.
							• usecount: Module usage counter. The counter is incremented when an operation involving
							the module's functions is started and decremented when the operation terminates.
							• flags: Module flags.
							• nsyms: Number of exported symbols.
							• ndeps: Number of referenced modules
							• *syms: Pointer to this module's symbol table.
							• *deps: Pointer to list of modules the are referenced by this module.
							• *refs: Pointer to list of modules that use this module							
					</section>
				</section>
				<!-- Kernel Modules -->
				<section>
					<section>
						<h1>Kernel Modules</h1>
					</section>
					<section style="font-size: 0.8em; text-align: left">
						<h4>Why modules?</h4>
						<ul>
							<li>Dapat mengimplementasikan device driver, file system, networking protocol pada Linux.</li>
							<li>Dapat mengcompile dan memodifikasi kernel code dengan lebih mudah (Dynamic Linking).</li>
							<li>Dapat didistribusikan ke user lain (It’s FREE!!).</li>
							<li>Dengan Kernel Modules, Linux System bisa di set up dengan standar minimal.</li>
						</ul>							
					</section>
					<section style="font-size: 0.8em; text-align: left">
						<h4>4 Komponen Linux module:</h4>
						<ul>
							<li>Module Management System</li>
							<li>Module Loader and Unloader</li>
							<li>Driver-Registration System</li>
							<li>Conflict Resolution Mechanism</li>
						</ul>
					</section>
					<section>
						<h4>Module Management</h4>
						<div style="display: flex; text-align: left; font-size: 0.5em">
							<div style="width: 50%; margin: 10px" class="fragment">
								<p>Seperti file bertipe o. Kodenya sudah ada tapi belum tahu addressnya.</p>
								<p>Misalnya:</p>
								<ul>
									<li>*UND* yang harus disambungkan dengan yang ada di dalam kernel</li>
									<li>.text sebagai offset fungsi yang disediakan oleh module</li>
								</ul>
							</div>
							<div style="width: 50%; margin: 10px" class="fragment">
								<p>Proses:</p>
								<ul>
									<li>Module loader didalam kernel melihat symbol yang masih *UND* lalu 
										dicoba diciptakan dengan symbol table kernel dan semua symbol *UND* harus ketemu. </li>
									<li>Jika tidak, maka akan error.</li>
									<li>Jika ada, akan dialokasi memory di dalam kernel untuk menyimpan modulnya.</li>
									<li>Realokasi *UND* akan diisi dengan address symbol yang sudah ada di kernel. 
										Realokasi address dalam module akan disesuikan dengan address memory yang dialokasikan.</li>
									<li>Semua symbol yang diekspor oleh module akan ditambahkan ke dalam symbol table kernel agar 
										module lain  dapat memakainya</li>
								</ul>
							</div>
						</div>
					</section>
					<section>
						<h4>Modprobe</h4>
						<p style="font-size: 0.8em">Karena itu, pada utility modprobe akan dicari semua dependencies dari sebuah module agar di load terlebih dahulu 
							sehingga semua requirements terpenuhi sebelum module ini di-load.</p>
					</section>
					<section>
						<h4>Driver Registration</h4>
						<p style="font-size: 0.8em">Kernel me-maintain tabel dinamik dari semua driver yang diketahui dan menyediakan beberapa langkah/perintah 
							untuk memperbolehkan menambah driver tambahan atau menghapusnya secara bebas dari tabel.</p>
						<p style="font-size: 0.8em">Kernel juga memastikan akan selalu memanggil module’s startup routine ketika module tersebut di-load ke 
							kernel serta memanggil module’s cleanup routine saat di-unload.</p>
					</section>
				</section>
				<!-- Process Management -->
				<section>
					<section>
						<h1>Process Management</h1>
					</section>
					<section>
						<q>adalah servis dasar dari setiap OS kepada user. Karena Linux merupakan turunan UNIX sistem, maka akan ada 
							beberapa proses yang mirip dengan yang ada di UNIX dan ada yang berbeda. Kali ini akan dibahas kita 
							akan mereview bagaimana yang di UNIX dan mengenalkan beberapa tambahan manajemen dari Linux.</q>
						<br><br>
						<p style="font-size: 0.8em; text-align: right"><i>- Raja, Hagai -</i></p>
					</section>
					<section style="text-align: left">
						<h3>Model Proses</h3>
						<p><b>Fork</b> -> create new Process</p>
						<p><b>Exec</b> -> run a program</p>
						<p style="font-size: 0.8em">Benar2 terpisah, kita bisa create process tanpa menjalankan sebuah program dan sebaliknya. 
							Kapan saja ketika kita butuh environment beda buat proses baru dalam program dan jika environmentnya 
							sama dalam satu proses tinggal panggil saja programnya.</p>		
						<p style="color: #008299" class="fragment">Untuk tetap menjaga setiap eksekusi terkontrol di Linux ada 3 properti yang dimiliki oleh tiap proses.</p>
					</section>
					<section>
						<h4 style="text-align: right">Process Identity</h4>
						<div style="text-align: left; font-size: 0.6em">
							<p class="fragment"><b>PID</b> -> identifier unik setiap proses, selanjutnya ini menjadi informasi yang berkaitan dengan setiap proses 
							yang bergrup melalui fork satu program (tree processed fork) dan login session.</p>
							<p class="fragment"><b>Credential</b> -> setiap proses akan memiliki atribut user ID dan group ID untuk menentukan apa yang boleh dilakukan untuk proses itu.</p>
							<p class="fragment"><b>Personality</b> -> biasanya tidak ada di UNIX, tapi di Linux yang boleh mengubah semantik dari suatu syscall hal ini 
								digunakan untuk menyatakan syscall yang ada pada proses akan kompatibel dengan suatu variasi UNIX.</p>
							<p class="fragment"><b>Namespace</b> -> view file system yang dipegang proses itu. Untuk user ID dan group ID dapat diubah saat 
								proses berjalan asal memenuhi security check. Tapi PID tidak bisa, harus sampai proses mati.</p>
						</div>
					</section>
					<section>
						<h4 style="text-align: right">Process Environment</h4>
						<p class="fragment" style="text-align: left">Menyimpan dua informasi,</p>
						<div style="text-align: left; font-size: 0.7em">
							<p class="fragment"><b>Argument vector</b> -> command line yang sedang dieksekusi</p>
							<p class="fragment"><b>Environment vector</b> -> list name=value yang menyatakan variabel2 yang terkait dengan proses.
								Hal ini tidak berubah dan tidak memiliki alternatif untuk setiap proses. Jadi untuk setiap program baru yang akan dijalankan, 
								proses akan mempass argument variabel ke kernel dan kernel akan mengubah environment yang ada pada program yang baru itu.</p>
						</div>
					</section>
					<section>
						<h4 style="text-align: right">Process Context</h4>
						<p class="fragment" style="text-align: left; font-size: 0.6em">(1) dan (2) mungkin statis dan tidak berubah sepanjang proses berjalan. 
							Kalau yang ini berubah terus sepanjang satu waktu. Isinya adalah:</p>
						<div style="text-align: left; font-size: 0.55em">
							<p class="fragment"><b>Scheduling Context</b> -> menyimpan stack proses yang akan dieksekusi</p>
							<p class="fragment"><b>Accounting</b> -> menghitung jumlah resource yang sedang dipakai dan total 
								resource yang dipakai sebuah proses sepanjang hidupnya.</p>
							<p class="fragment"><b>File Table</b> -> menyimpan data open file. Saat I/O syscall, proses akan memanggil file 
								yang digunakan dengan passing integer sesuai dengan table saat itu</p>
							<p class="fragment"><b>File-system Context</b> ->dibuat untuk menyimpan data file sistem yang dapat dibuka termasuk root directory, 
								directory saat ini dan namespace.</p>
							<p class="fragment"><b>Signal-Handler table</b> -> menyimpan data signal dan apa yang harus dilakukan terhadap sinyal itu kepada proses. 
								Sinyal itu bisa datang kapan saja untuk misalnya mematikan suatu proses.</p>
							<p class="fragment"><b>Virtual memory context</b> -> menjelaskan seluruh konten proses. Akan dibahas di 18.6</p>
						</div>
					</section>
					<section style="text-align: left">
						<h3>Process and Threads</h3>
						<p style="font-size: 0.7em">Fork untuk duplikasi proses tanpa load satu program baru. Boleh juga membuat thread baru melalui clone. Linux tidak membedakan antara thread dan proses. 
							Hanya saja kedua fungsi ini bedanya untuk clone ada flags yang mempass resource apa yang di share antara parent dan child.</p>
						<img src="img/linux/pm1.jpg" alt="">
						<p style="font-size: 0.7em">Jika semua flag dipass maka sama seperti model pemanggilan thread di Sistem lain dan jika semua tidak di pass akan sama seperti fork karena tidak ada penurunan shared resource.</p>
					</section>
				</section>

				<!-- Scheduling -->
				<section>
					<section>
						<h1>Scheduling</h1>
					</section>
					<section>
						<p>Seperti di semua UNIX, Linux memakai preemptive multitasking (menentukan sebuah proses ditahan untuk dikerjakan selama berapa lama berdasarkan parameter tertentu). 
							Dalam sistem seperti ini scheduler memutuskan proses apa di run kapan. Bukan hanya sekedar user proses, tetapi juga tugas kernel-kernel.</p>
					</section>
					<section style="text-align: left">
						<h3>Process Scheduling</h3>
						<p style="font-size: 0.8em">Ada dua algoritma scheduling yang dipakai di Linux. <b>Time-sharing algorithm</b> yakni preemptive scheduling pada tiap proses agar adil. 
							Satu lagi yaitu untuk real-time task yang mendahulukan prioritas daripada adil. Sehingga Linux Scheduler memberi setiap proses dua variabel yaitu time slice 
							yakni waktu untuk proses ditahan di prosesor dan nice value bernilai (-20) - 19. Nilai nice value semakin kecil berarti lebih prioritas.</p>
					</section>
					<section>
						<p style="font-size: 0.7em">Dalam aplikasinya, bentuk scheduler ini memakai <b>Red-Black Tree</b></p>
						<img src="img/linux/sc1.jpg" alt="">
					</section>
					<section style="text-align: left">
						<h3>Real-Time Scheduling</h3>
						<p style="font-size: 0.8em">Untuk beberapa proses tingkat bawah Linux juga mengaplikasikan algoritma FCFS dan Round Robin untuk real-time schedulingnya. 
							Jadi operasi dasar dengan prioritas yang sama akan didahulukan yang memiliki waiting time lebih besar.Scheduling ini dipakau untuk mengatur proses dari tugas kernel-kernel.</p>
					</section>
					<section style="text-align: left">
						<h3>Kernel Synchronization</h3>
						<p style="font-size: 0.7em">Request untuk Eksekusi di tingkat kernel dapat terjadi dalam dua cara yaitu eksplisit (menggunakan syscall) dan implicit (contoh saat page fault). 
							Serta dapat pula menambahkan interrupt baru yang membuat CPU mengeksekusi kernel-defined handler untuk interrupt itu (Tubes OS).</p>
						<p class="fragment" style="font-size: 0.7em; color: red">Masalahnya adalah saat seluruh tugas ini mencoba mengakses internal data structure yang sama. Hal ini kasusnya mirip dengan masalah critical section, 
							hanya saja disini tugas kernel harus tetap berjalan dengan tetap menjaga integritas data.</p>
					</section>
					<section style="text-align: left">
						<h3>Symmetric Multiprocessing</h3>
						<p style="font-size: 0.7em"></p>
					</section>
				</section>

				<!-- Memory Management -->
				<section>
					<section>
						<h1>Memory Management</h1>
					</section>
				</section>

				<!-- File Systems -->
				<section>
					<section>
						<h1>File Systems</h1>
					</section>
				</section>
				<!-- I/O -->
				<section>
					<section>
						<h1>I/O Devices</h1>
					</section>
					<section style="text-align: left">
						<h4>Block Devices</h4>
						<p style="font-size: 0.7em">atau yang sering disebut sebagai random access device 
							adalah alat yang menyimpan data dan menawarkan akses ke seluruh bagian secara acak. 
							Contoh block device adalah hard disk dan floppy disk. Dengan menggunakan hard disk, 
							kita dapat mengakses data yang tersimpan secara acak.</p>
					</section>
					<section style="text-align: left">
						<h4>Character Devices</h4>
						<p style="font-size: 0.7em">terdiri dari device seperti mouse dan keyboard. Perbedaan 
							mendasar antara block dan character device adalah, block devices diakses secara random, 
							sementara character device diakses secara serial (berurutan). Cara kerja character device 
							adalah membaca serangkaian karakter secara berurut, misalnya serangkaian karakter yang 
							ditekan di keyboard ataupun serangkaian data byte yang dikirim melalui serial line.</p>
					</section>
					<section style="text-align: left">
						<h4>Network Devices</h4>
						<p style="font-size: 0.7em">paling berbeda diantara yang lain. User tidak bisa secara langsung 
							mentransfer data ke network device. Tetapi user harus berkomunikasi secara tidak langsung 
							dengan cara membuka koneksi ke subsistem network pada kernel.</p>
					</section>
				</section>
				<!-- IPC -->
				<section>
					<section>
						<h1>Interprocess Communication</h1>
					</section>
					<section>
						<p>Linux menyediakan lingkungan untuk proses saling berkomunikasi seperti memberitahu proses lain bahwa suatu event muncul, 
							berjalan atau telah berhenti, atau mentransfer data dari satu proses ke proses lainnya.</p>
					</section>
					<section style="text-align: left">
						<h3>Synchronization and Signals</h3>
						<p style="font-size: 0.8em">Dalam komunikasi antar proses, Linux memberikan sebuah mekanisme standar menggunakan signal. Fungsi signal yaitu 
							menginformasikan bahwa suatu event telah terjadi kepada suatu proses. Suatu proses (termasuk kernel) 
							dapat mengirimkan signal kepada proses lain, dengan syarat sinyal yang dikirim dimiliki pengguna yang berbeda. </p>
					</section>
				</section>
				<!-- Network Structure -->
				<section>
					<section>
						<h1>Network Structure</h1>
					</section>
				</section>
				<!-- Security -->
				<section>
					<section>
						<h1>Security</h1>
					</section>
					<section style="text-align: left">
						<h3>Dibagi menjadi 2</h3>
						<br>
						<span class="fragment">
							<b>Authentication</b> -> memastikan bahwa hanya orang-orang yang mempunyai
							hak yang bisa mengakses sistem
						</span>
						<br><br>
						<span class="fragment">
								<b>Access Control</b> -> Mekanisme yang mengatur apakah suatu 
								user punya hak untuk mengakses suatu file
						</span>
					</section>
					<section>
						<q style="text-align: left; font-size: 0.8em">Biasanya diimplementasi dengan menggunakan <i>password</i> + <b>salt value</b> yang dimasukkan ke <i>one-way function</i>. 
							Salt value adalah sebuah random string yang di <i>concat</i> dengan passwordnya. Misal password: <b>love123 salt</b> = <b>14ksL!</b> 
							Maka akan menjadi <b>love12314ksL!</b> Kombinasi tersebut dimasukkan ke <i>one-way function</i>, 
							yang berarti hasil dari fungsi hashing tersebut tidak dapat di decode kembali.
						</q>
						<br><br>
						<h3 style="text-align: right">Authentication</h3>
						<p style="font-size: 0.7em; text-align: right"><i>Adylan, 1990</i></p>
					</section>
					<section>
						<p><b>PAM</b> (Pluggable Authentication Module)</p>
						<p>Sebuah shared library untuk sistem-sistem yang membutuhkan autentikasi user. (more on this later)</p>
					</section>
					<section>
						<h3>Access Control</h3>
						<div style="display: flex; font-size: 2.5em; color: aqua">
							<p class="fragment">UserID (uid)</p>
							<p class="fragment">GroupID (gid)</p>
						</div>
					</section>
					<section>
						<div style="display: flex; text-align: center">
							<img style="width: 35%; height: 100%; margin: 20px" src="img/linux/sec1.jpg" alt="">
							<img style="width: 50%; height: 100%; margin: 20px" src="img/linux/sec2.jpg" alt="">
						</div>
					</section>
					<section>
						<h4 style="color: aqua">1 UID, banyak GID</h4>
						<p>Semua objek pada Linux memiliki sebuah UID dan GID</p>
						<p style="font-size: 0.65em">Apabila UID pengakses cocok dengan UID objek, maka pengakses punya user rights.</p>
						<p style="font-size: 0.65em">Apabila GID pengakses cocok dengan GID objek, maka pengakses punya group rights.</p>
					</section>
					<section>
						<h3 style="color: red">MELTDOWN SPECTRE</h3>
						<img src="img/linux/sec3.jpg" class="fragment" alt="">
					</section>
					<section>
						<h3 style="color: rgb(0, 214, 71)">Address Space Layout Randomization (ASLR) </h3>
						<div style="font-size: 0.7em">
							<p class="fragment" >Dulu hacker biasanya melakukan serangan dengan mengetahui atau menebak lokasi address space 
								sehingga bisa melakukan penyalahgunaan dari sana.</p>
							<p class="fragment">Address space layout randomization mencegah itu semua dengan melakukan pengacakan address space 
								sehingga hacker sulit untuk mengetahui address space untuk melakukan serangan</p>								
						</div>
					</section>
				</section>
			</div>
		</div>
		<!-- <span id="open-menu" onclick="openNav()">&#9776; open</span> -->
		<div id="myNav" class="overlay-menu">
			<a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>
			<div class="overlay-menu-content">
				<a href="#/1">History of Linux</a>
				<a href="#/2">Design Principles</a>
				<a href="#/3">Kernel Modules</a>
				<a href="#/4">Process Management</a>
				<a href="#/5">Scheduling</a>
				<a href="#/6">Memory Management</a>
				<a href="#/7">File Systems</a>
				<a href="#/8">I/O Devices</a>
				<a href="#/9">IPC</a>
				<a href="#/10">Network Structures</a>
				<a href="#/11">Security</a>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,
				transition: 'slide',
				dependencies: [
				{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});

			function openNav() {
    			document.getElementById("myNav").style.width = "100%";
			}

			function closeNav() {
				document.getElementById("myNav").style.width = "0%";
			}
		</script>
	</body>
</html>
