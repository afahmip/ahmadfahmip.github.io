<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Slide Linux</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<style>
			#open-menu {
				color: #00a5c2;
				margin-left: 3vh;
				margin-top: 3vh;
				font-family: 'Segoe UI';
				position: absolute;
				font-size: 0.5em;
				cursor:pointer;
				z-index: 100;
			}

			.overlay-menu {
				font-family: 'Segoe UI';
				height: 100%;
				width: 0;
				position: fixed;
				z-index: 1000;
				top: 0;
				left: 0;
				background-color: rgb(0,0,0);
				background-color: rgba(0,0,0, 0.9);
				overflow-x: hidden;
				transition: 0.5s;
			}

			.overlay-menu-content {
				position: relative;
				top: 15%;
				width: 100%;
				text-align: center;
				margin-top: 30px;
			}

			.overlay-menu a {
				padding: 8px;
				text-decoration: none;
				font-size: 2em;
				color: #818181;
				display: block;
				transition: 0.3s;
			}

			.overlay-menu a:hover, .overlay-menu a:focus {
				color: #f1f1f1;
			}

			.overlay-menu .closebtn {
				position: absolute;
				top: 20px;
				right: 45px;
				font-size: 60px;
			}

			@media screen and (max-height: 450px) {
				.overlay-menu a {font-size: 20px}
				.overlay-menu .closebtn {
					font-size: 40px;
					top: 15px;
					right: 35px;
				}
			}
		</style>
	</head>
	<body>
		<div class="reveal">
			<span id="open-menu" onclick="openNav()">&#9776; Navigate</span>
			<!-- <button id="open-menu" onclick="openNav()">Navigate</button> -->
			<div class="slides">
				<section style="text-align: left" data-background="#f7f7f7">
					<h1 style="color: #ffbf00">Kitab Linux</h1>
					<h4 style="font-size: 0.75em; color: #5b5b5b">Oleh: Sammy, Joseph, Fahmi, Gery, Tanor, Ody, Hagai, Eka</h4>
					<!-- <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/35/Tux.svg/2000px-Tux.svg.png" alt=""> -->
				</section>

				<!-- Sejarah Linux -->
				<section>
					<section data-background="#fcfcfc">
						<h1>Sejarah Linux</h1>
						<p style="color: #008299">Sebuah kisah yang mengubah umat manusia</p>
					</section>
					<section>
						<img src="https://img.memecdn.com/linus-torvalds-the-good-linux-creator_o_3334599.jpg" alt="">
						<p style="font-size: 0.6em">Mari mengucap syukur kepada Tuhan karena telah menciptakan <b>Linus Torvalds</b>.</p>
					</section>
					<section style="font-size: 0.7em" data-background="#bfbfbf">
						<p>Pada awal mula, setelah Bell Labs cabut dari development mutex, 
							Ken Thompson menciptakan UNIX dan Dennis Richie menciptakan bahasa C. 
							Bell Labs adalah anak perusahan dari Alcatel-Lucent, tapi karena hukum monopoli dan sebagainya sehingga perusahaan tersebut dipecah dan banyak asetnya dipindahkan kemana mana.</p>
					</section>
					<section style="font-size: 0.7em" data-background="#848484">
						<p>Beberapa vendor yang memiliki lisensi UNIX membuat implementasinya sendiri, 
							beserta beberapa universitas dengan mahasiswanya masing - masing. AT&T melarang 
							penggunaan UNIX untuk menjadi bahan pembelajaran di Universitas yang tidak memiliki 
							lisensi UNIX. System yang merupakan standar dari UNIX di dunia, turunannya seperti IBM EIX, Sans Solaris, HP-UX.</p>
					</section>
					<section style="font-size: 0.7em" data-background="#4f4f4f">
						<p>Sementara itu, University of California, Berkeley, mahasiswanya membuat banyak modifikasi pada UNIX yaitu BSD hingga versi 4. Pada tahun 90-an, muncul pertanyaan siapa yang memiiki hak cipta terhadap UNIX, dan Berkeley tidak mampu mendistribusikan BSD karena memiliki 
							 sebagian code UNIX. Lalu Berkeley mendistribusikan BSD yang pure tanpa code UNIX.</p>
					</section>
					<section style="font-size: 0.7em">
						<p>Tahun 90an Prof Andrew Tanenbaum menulis MINIX yang ymeniru UNIX namun designnya beda. Komunitas BSD ingin mengubah BSD menjadi sistem UNIX yang lengkap. Saat itu, GNU dan MINIX merupakan dua kontingen besar dalam sistem operasi. Lalu muncullah <b style="color: orange">Linus Torvalds dari Helsinki</b>, yang mencoba - coba membuat OSnya sendiri karena MINIX dianggap tidak bebas atas adanya banyak batasan. Tahun 1991, Torvalds membuat sebuah pengumuman bahwa dia membuat sebuah operating system 
							kecil yang disebut LINUX. Richard Stallman membuat GNU menjadi sebuah program yang bebas dari 
							copyrght orang lain. Saat LINUX muncul, GNU masih kesulitan membuat kernel mereka. Sehingga mereka 
							membuat LINUX menjadi dasar kernel dan userspacenya GNU. Lalu mereka mengambil beberapa software 
							yang berguna lalu meng - compile semuanya agar bisa bekerja sebagai suatu sistem. Dalam Android, 
							LINUX digunakan sebagai kernel dengan library yang didevelop oleh Google.</p>
					</section>
				</section>

				<!-- Design Principles -->
				<section data-background="#f7f7f7">
					<section>
						<h1>Design Principles</h1>
					</section>
					<section style="font-size: 0.7em; text-align: left">
						<h4>Kernel</h4>
						<p>kernel melakukan berbagai abstraksi dari sebuah sistem operasi, seperti : Signal, System calls, Process dan Sheduler, 
							Virtual Memory, File systems, Network protocols, Character Device Drivers, Block Device Drivers, Network Device Drivers, Trap dan Faults, Physical Memory, Interrupts.</p>
					</section>
					<section>
						<img src="img/linux/dp1.jpg" alt="">
					</section>
					<section style="font-size: 0.7em; text-align: left">
						<h4>System Libraries</h4>
						<p>merupakan kumpulan fungsi-fungsi standar yang dipakai oleh aplikasi untuk dapat berinteraksi dengan kernel. Fungsi - fungsi ini mengimplemen fungsionalitas
							 yang tidak membutuhkan privilage penuh dari kernel code. Library yang paling penting : C library (libc). System libraries memberikan berbagai fungsionalitas,
							  baik dari syscall yang paling basic hingga kompleks, seperti menjalankan syscall untuk mentransfer kontrol dari user mode ke kernel mode, file handling,
							   algoritma sorting, fungsi matematis, manipulasi string.</p>
					</section>
					<section style="font-size: 0.7em; text-align: left">
						<h4>System Utilities</h4>
						<p>program yang menjalankan tugas khusus secara tersendiri. Beberapa utilitas dijalankan sekali saja dan kemudian melakukan konfigurasi beberapa aspek pada sistem. 
							Yg lainnya, yaitu daemons dijalankan secara permanen : contoh, <b>menerima koneksi (http daemon, ftp, ssh, telnet, bisa juga service, dkk) serta menerima logon requests, 
							mengupdate log file</b>, dan masih banyak lagi. Salah satu system utilities yang paling penting yaitu Shell, sebagai standard command line interface untuk UNIX. 
							Kebanyakan linux pakai BASH (Bourne Again Shell). Ada jg shell yang lain sepert ZSH, yaitu Z shell. Shell dipakai untuk menerima inputan dari user dan kemudian menjalankan perintah yang diminta. </p>
					</section>
					<section style="font-size: 0.7em">
						<h3>Kernel vs User</h3>
						<p>Kode pada kernel dapat mengeksekusi semua intruksi pada prosesor secara penuh. Kernel dapat mengakses physical resource ( hardware, driver, dkk) pada komputer.  
							Pada Linux, disebut sebagai kernel mode. Di sini, tidak ada user code yang dimasukan dan dibangun.</p>
						<p>Setiap kode yang tidak dibutuhkan untuk jalan di kernel mode diletakkan pada system libraries dan hanya berjalan di dalam user mode. 
							User mode hanya dapat mengakses ke beberapa bagian pada system resources yang sudah dicontrol.</p>
					</section>
					<section>
						<div style="display: flex;">
							<h3>Model Linux&nbsp;&nbsp;</h3>
							<h3 style="color: rgb(46, 194, 194)" class="fragment">Monolithic + Modular</h3>
						</div>
						<div style="font-size: 0.55em; text-align: left">
							<div class="fragment">
								<p><b>Model linux menggunakan model monolitik:</b></p>
								<ul>
									<li>Kode kernel dan struktur data seperti core scheduling, virtual memory, device drivers, file systems, dan networking code diletakan pada satu address memory yang sama.</li>
									<li>Meningkatkan efisiensi dan performance (tidak perlu context switch).</li>
									<li>Design yang lebih simpel.</li>
								</ul>
							</div>
							<br>
							<div class="fragment">
								<p><b>Kernel Linux juga masih menyediakan ruang untuk modularitas:</b></p>
								<ul>
									<li>User dapat me-load shared libraries modules secara dinamik pada saat run time.</li>
									<li>Module ini benar-benar independen terhadap kernel dan disebut loadable module.</li>
									<li>
										2 Karakteristik penting:
										<ul>
											<li>Dynamic Linking -> bisa diload dan di keluarkan dari memory kapan saja</li>
											<li>Stackable Module -> sistem hierarkis, user paling atas</li>
										</ul>
									</li>
								</ul>
							</div>
						</div>
					</section>
					<section>
						<p style="font-size: 0.75em">Salah satu perintah untuk menambahkan kernel module yaitu dengan perintah insmod ataupun modprobe. Keduanya punya fungsi yang sama, namun modprobe dapat mengecek dependencies dari module yang dimasukkan.</p>
						<p class="fragment" style="font-size: 0.75em">Syntax : insmod [file name] [module-options...]</p>
						<div class="fragment" data-markdown>
							<script type="text/template">
								```

								insmod /path/to/snd-usb-audio.ko snd-cmipci snd_id="first" snd_mpu_port=0x330

								```
							</script>
						</div>
					</section>
					<section>
						<p>Command lain yang berhubungan yaitu:</p>
						<ul>
							<li><b>Lsmod</b> -> melihat list dari modules yang ada</li>
							<li><b>Rmmod</b> -> menghapus modules</li>
							<li><b>Depmod</b> -> menggenerate modules.dep dlsb</li>
						</ul>					
					</section>
					<section>
						<div style="display: flex; justify-content: center; font-size: 0.7em">
							<h5>Setiap module di-defined oleh&nbsp;&nbsp;</h5>
							<h5 style="color: rgb(46, 194, 194)" class="fragment">Module dan Symbol Table</h5>
						</div>
						<p class="fragment" style="font-size: 0.6em">Elemen pada <i>Module Table</i></p>
						<div style="text-align: left; display: flex; font-size: 0.55em">
							<div class="fragment">
								<ul>
									<li>*next: Pointer ke module berikutnya. Setiap module diatur ke dalam Linked List dengan list awal adalah Pseudomodule.</li>
									<li>*name: Pointer ke nama module.</li>
									<li>size: Ukuran Module</li>
									<li>nsyms: Jumlah symbol yang diexport.</li>
									<li>*deps: Pointer ke list modules yang direfer.</li>
								</ul>
							</div>
							<div class="fragment">
								<ul>
									<li>usecount: Module usage counter. Counter ditambah ketika dipakai dan dikurang ketika diterminates.</li>
									<li>ndeps: Jumlah module yang direfer</li>
									<li>flags: Module flags</li>
									<li>*syms: Pointer tke system table dari module tersebut.</li>
									<li>*refs: Pointer to list modules yang menggunakan modules ini.</li>
								</ul>
							</div>
						</div>
					</section>
					<section>
						<img src="img/linux/dp2.jpg" alt="">
					</section>
				</section>

				<!-- Kernel Modules -->
				<section>
					<section>
						<h1>Kernel Modules</h1>
					</section>
					<section style="font-size: 0.8em; text-align: left">
						<h4>Why modules?</h4>
						<ul>
							<li>Dapat mengimplementasikan device driver, file system, networking protocol pada Linux.</li>
							<li>Dapat mengcompile dan memodifikasi kernel code dengan lebih mudah (Dynamic Linking).</li>
							<li>Dapat didistribusikan ke user lain (It’s FREE!!).</li>
							<li>Dengan Kernel Modules, Linux System bisa di set up dengan standar minimal.</li>
						</ul>							
					</section>
					<section style="font-size: 0.8em; text-align: left">
						<h4>4 Komponen Linux module:</h4>
						<ul>
							<li>Module Management System</li>
							<li>Module Loader and Unloader</li>
							<li>Driver-Registration System</li>
							<li>Conflict Resolution Mechanism</li>
						</ul>
					</section>
					<section>
						<h4>Module Management</h4>
						<div style="display: flex; text-align: left; font-size: 0.5em">
							<div style="width: 50%; margin: 10px" class="fragment">
								<p>Seperti file bertipe o. Kodenya sudah ada tapi belum tahu addressnya.</p>
								<p>Misalnya:</p>
								<ul>
									<li>*UND* yang harus disambungkan dengan yang ada di dalam kernel</li>
									<li>.text sebagai offset fungsi yang disediakan oleh module</li>
								</ul>
							</div>
							<div style="width: 50%; margin: 10px" class="fragment">
								<p>Proses:</p>
								<ul>
									<li>Module loader didalam kernel melihat symbol yang masih *UND* lalu 
										dicoba diciptakan dengan symbol table kernel dan semua symbol *UND* harus ketemu. </li>
									<li>Jika tidak, maka akan error.</li>
									<li>Jika ada, akan dialokasi memory di dalam kernel untuk menyimpan modulnya.</li>
									<li>Realokasi *UND* akan diisi dengan address symbol yang sudah ada di kernel. 
										Realokasi address dalam module akan disesuikan dengan address memory yang dialokasikan.</li>
									<li>Semua symbol yang diekspor oleh module akan ditambahkan ke dalam symbol table kernel agar 
										module lain  dapat memakainya</li>
								</ul>
							</div>
						</div>
					</section>
					<section>
						<h4>Modprobe</h4>
						<p style="font-size: 0.8em">Karena itu, pada utility modprobe akan dicari semua dependencies dari sebuah module agar di load terlebih dahulu 
							sehingga semua requirements terpenuhi sebelum module ini di-load.</p>
					</section>
					<section>
						<h4>Driver Registration</h4>
						<p style="font-size: 0.68em">Kernel me-maintain tabel dinamik dari semua driver yang diketahui dan menyediakan beberapa langkah/perintah 
							untuk memperbolehkan menambah driver tambahan atau menghapusnya secara bebas dari tabel.</p>
						<p style="font-size: 0.68em">Kernel juga memastikan akan selalu memanggil module’s startup routine ketika module tersebut di-load ke 
							kernel serta memanggil module’s cleanup routine saat di-unload.</p>
					</section>
					<section style="text-align: left; font-size: 0.7em">
						<p>Setiap module dapat mendaftarkan beberapa fungsionalitas. </p>
						<div class="fragment">
							<p>Registration Tables biasanya terdiri dari beberapa tipe:</p>
							<ul>
								<li><b>Device Drivers</b> : character devices (seperti printers, terminals, and mice), block devices (disk drives), dan network interface devices.</li>
								<li><b>File Systems</b> : format untuk menyimpan data. Saat ini, format yang paling banyak dipakai : ext4.</li>
								<li><b>Network Protocols</b> : TCP, UDP, packet filtering rules, firewall, dkk.</li>
								<li><b>Binary Format</b> : membaca, menulis, dan mengeksekusi file.</li>
							</ul>
						</div>
					</section>
					<section style="text-align: left">
						<h4>Conflict Resolution</h4>
						<h4 class="fragment" style="color: red;">PROBLEM?</h4>
						<div style="font-size: 0.7em">
							<p class="fragment">PC hardware semakin banyak konfigurasi dan semakin banyak jumlah device driver seperti network cards dan video display adapters dari berbagai aplikasi, merk, dan lain sebagainya. Akibatnya untuk me-manage konfigurasi dari hardware menjadi lebih sulit apalagi jika diimplementasikan secara modular menjadi variabel yang dinamis.</p>
							<ul class="fragment">
								<li>Mencegah modul untuk mengakses hardware resources secara bersamaan.</li>
								<li>Mencegah autoprobes -> auto detect devices.</li>
								<li>Mencegah konflik yang muncul dari driver-driver yang mengakses hardware yang sama.</li>
							</ul>
						</div>
					</section>
					<section style="text-align: left; font-size: 0.7em">
						<p>Caranya:</p>
						<p class="fragment">Kernel menyediakan list dari hardware resources yang sudah di-allocate. </p>
						<p class="fragment">Saat device driver akan mengakses resource tersebut, driver tersebut akan me-reserve pada database kernel agar system administrator mengetahui dan menentukan resource mana yang sedang digunakan saat itu.</p>
					</section>
				</section>

				<!-- Process Management -->
				<section>
					<section>
						<h1>Process Management</h1>
					</section>
					<section>
						<q>adalah servis dasar dari setiap OS kepada user. Karena Linux merupakan turunan UNIX sistem, maka akan ada 
							beberapa proses yang mirip dengan yang ada di UNIX dan ada yang berbeda. Kali ini akan dibahas kita 
							akan mereview bagaimana yang di UNIX dan mengenalkan beberapa tambahan manajemen dari Linux.</q>
						<br><br>
						<p style="font-size: 0.8em; text-align: right"><i>- Raja, Hagai -</i></p>
					</section>
					<section style="text-align: left">
						<h3>Model Proses</h3>
						<p><b>Fork</b> -> create new Process</p>
						<p><b>Exec</b> -> run a program</p>
						<p style="font-size: 0.8em">Benar2 terpisah, kita bisa create process tanpa menjalankan sebuah program dan sebaliknya. 
							Kapan saja ketika kita butuh environment beda buat proses baru dalam program dan jika environmentnya 
							sama dalam satu proses tinggal panggil saja programnya.</p>		
						<p style="color: #008299" class="fragment">Untuk tetap menjaga setiap eksekusi terkontrol di Linux ada 3 properti yang dimiliki oleh tiap proses.</p>
					</section>
					<section>
						<h4 style="text-align: right">Process Identity</h4>
						<div style="text-align: left; font-size: 0.6em">
							<p class="fragment"><b>PID</b> -> identifier unik setiap proses, selanjutnya ini menjadi informasi yang berkaitan dengan setiap proses 
							yang bergrup melalui fork satu program (tree processed fork) dan login session.</p>
							<p class="fragment"><b>Credential</b> -> setiap proses akan memiliki atribut user ID dan group ID untuk menentukan apa yang boleh dilakukan untuk proses itu.</p>
							<p class="fragment"><b>Personality</b> -> biasanya tidak ada di UNIX, tapi di Linux yang boleh mengubah semantik dari suatu syscall hal ini 
								digunakan untuk menyatakan syscall yang ada pada proses akan kompatibel dengan suatu variasi UNIX.</p>
							<p class="fragment"><b>Namespace</b> -> view file system yang dipegang proses itu. Untuk user ID dan group ID dapat diubah saat 
								proses berjalan asal memenuhi security check. Tapi PID tidak bisa, harus sampai proses mati.</p>
						</div>
					</section>
					<section>
						<h4 style="text-align: right">Process Environment</h4>
						<p class="fragment" style="text-align: left">Menyimpan dua informasi,</p>
						<div style="text-align: left; font-size: 0.7em">
							<p class="fragment"><b>Argument vector</b> -> command line yang sedang dieksekusi</p>
							<p class="fragment"><b>Environment vector</b> -> list name=value yang menyatakan variabel2 yang terkait dengan proses.
								Hal ini tidak berubah dan tidak memiliki alternatif untuk setiap proses. Jadi untuk setiap program baru yang akan dijalankan, 
								proses akan mempass argument variabel ke kernel dan kernel akan mengubah environment yang ada pada program yang baru itu.</p>
						</div>
					</section>
					<section>
						<h4 style="text-align: right">Process Context</h4>
						<p class="fragment" style="text-align: left; font-size: 0.6em">(1) dan (2) mungkin statis dan tidak berubah sepanjang proses berjalan. 
							Kalau yang ini berubah terus sepanjang satu waktu. Isinya adalah:</p>
						<div style="text-align: left; font-size: 0.55em">
							<p class="fragment"><b>Scheduling Context</b> -> menyimpan stack proses yang akan dieksekusi</p>
							<p class="fragment"><b>Accounting</b> -> menghitung jumlah resource yang sedang dipakai dan total 
								resource yang dipakai sebuah proses sepanjang hidupnya.</p>
							<p class="fragment"><b>File Table</b> -> menyimpan data open file. Saat I/O syscall, proses akan memanggil file 
								yang digunakan dengan passing integer sesuai dengan table saat itu</p>
							<p class="fragment"><b>File-system Context</b> ->dibuat untuk menyimpan data file sistem yang dapat dibuka termasuk root directory, 
								directory saat ini dan namespace.</p>
							<p class="fragment"><b>Signal-Handler table</b> -> menyimpan data signal dan apa yang harus dilakukan terhadap sinyal itu kepada proses. 
								Sinyal itu bisa datang kapan saja untuk misalnya mematikan suatu proses.</p>
							<p class="fragment"><b>Virtual memory context</b> -> menjelaskan seluruh konten proses. Akan dibahas di 18.6</p>
						</div>
					</section>
					<section style="text-align: left">
						<h3>Process and Threads</h3>
						<p style="font-size: 0.7em">Fork untuk duplikasi proses tanpa load satu program baru. Boleh juga membuat thread baru melalui clone. Linux tidak membedakan antara thread dan proses. 
							Hanya saja kedua fungsi ini bedanya untuk clone ada flags yang mempass resource apa yang di share antara parent dan child.</p>
						<img src="img/linux/pm1.jpg" alt="">
						<p style="font-size: 0.7em">Jika semua flag dipass maka sama seperti model pemanggilan thread di Sistem lain dan jika semua tidak di pass akan sama seperti fork karena tidak ada penurunan shared resource.</p>
					</section>
				</section>

				<!-- Scheduling -->
				<section>
					<section>
						<h1>Scheduling</h1>
					</section>
					<section>
						<p>Seperti di semua UNIX, Linux memakai preemptive multitasking (menentukan sebuah proses ditahan untuk dikerjakan selama berapa lama berdasarkan parameter tertentu). 
							Dalam sistem seperti ini scheduler memutuskan proses apa di run kapan. Bukan hanya sekedar user proses, tetapi juga tugas kernel-kernel.</p>
					</section>
					<section style="text-align: left">
						<h3>Process Scheduling</h3>
						<p style="font-size: 0.8em">Ada dua algoritma scheduling yang dipakai di Linux. <b>Time-sharing algorithm</b> yakni preemptive scheduling pada tiap proses agar adil. 
							Satu lagi yaitu untuk real-time task yang mendahulukan prioritas daripada adil. Sehingga Linux Scheduler memberi setiap proses dua variabel yaitu time slice 
							yakni waktu untuk proses ditahan di prosesor dan nice value bernilai (-20) - 19. Nilai nice value semakin kecil berarti lebih prioritas.</p>
					</section>
					<section>
						<p style="font-size: 0.7em">Dalam aplikasinya, bentuk scheduler ini memakai <b>Red-Black Tree</b></p>
						<img src="img/linux/sc1.jpg" alt="">
					</section>
					<section style="text-align: left">
						<h3>Real-Time Scheduling</h3>
						<p style="font-size: 0.8em">Untuk beberapa proses tingkat bawah Linux juga mengaplikasikan algoritma FCFS dan Round Robin untuk real-time schedulingnya. 
							Jadi operasi dasar dengan prioritas yang sama akan didahulukan yang memiliki waiting time lebih besar.Scheduling ini dipakau untuk mengatur proses dari tugas kernel-kernel.</p>
					</section>
					<section style="text-align: left">
						<h3>Kernel Synchronization</h3>
						<p style="font-size: 0.7em">Request untuk Eksekusi di tingkat kernel dapat terjadi dalam dua cara yaitu eksplisit (menggunakan syscall) dan implicit (contoh saat page fault). 
							Serta dapat pula menambahkan interrupt baru yang membuat CPU mengeksekusi kernel-defined handler untuk interrupt itu (Tubes OS).</p>
						<p class="fragment" style="font-size: 0.7em; color: red">Masalahnya adalah saat seluruh tugas ini mencoba mengakses internal data structure yang sama. Hal ini kasusnya mirip dengan masalah critical section, 
							hanya saja disini tugas kernel harus tetap berjalan dengan tetap menjaga integritas data.</p>
					</section>
					<section>
						<img src="img/linux/sc2.jpg" alt="">
					</section>
					<section>
						<img src="img/linux/sc3.jpg" alt="">
					</section>
					<section style="text-align: left">
						<h3>Symmetric Multiprocessing</h3>
						<p style="font-size: 0.7em">Mulai ada di <b style="color: rgb(46, 194, 194)">Linux 2.0 Kernel</b>, yaitu memperbolehkan sebuah proses dieksekusi secara parallel dalam prosesor-prosesor yang berbeda. Pada saat itu hanya satu prosesor yang boleh mengeksekusi satu kernel-code.</p>
						<p class="fragment" style="font-size: 0.7em">Dalam <b style="color: rgb(46, 194, 194)">versi 2.2 single kernel spinlock (disebut juga BKL - Big Kernel Lock)</b> ditambahkan agar multiple proses dapat dijalankan secara konkuren dalam satu kernel. Namun hal ini cukup kasar karena menghentikan seluruh proses dalam kernel sekaligus.</p>
						<p class="fragment" style="font-size: 0.7em">Selanjutnya Linux mengubah sistem ini menjadi <b style="color: rgb(46, 194, 194)">multiple locks</b> yang tiap locknya didesain menjaga sebagian kecil subset dari kernel’s data structure.</p>
						<p class="fragment" style="font-size: 0.7em">Dalam kernel 3.0 bahkan telah ditambahkan <b style="color: rgb(46, 194, 194)">ever-finer locking, processor afiinity dan load-balancing algorithm.</b></p>
					</section>
				</section>

				<!-- Memory Management -->
				<section>
					<section>
						<h1>Memory Management</h1>
					</section>
					<section>
						<h3>Mempunyai <b>dua komponen</b></h3>
						<div style="display: flex; font-size: 0.6em">
							<p class="fragment">Yang pertama berperan dalam pada alokasi dan pembebasan memory fisik sperti halaman, kumpulan halaman dan block kecil dari RAM</p>
							<p class="fragment">Yang kedua menangani virtual memory dimana memory dipetakan ke alamat dari proses yang sedang berjalan.</p>
						</div>
						<p class="fragment" style="font-size: 0.75em; color: #00a5c2">Karena batasan hardware yang spesifik, Linux membagi memory fisik menjadi 4 zona berbeda.</p>
						<p class="fragment" style="font-size: 0.85em; color: aqua">ZONE DMA,ZONE DMA32, ZONE NORMAL,ZONE HIGHMEM.</p>
					</section>
					<section>
						<img src="img/linux/mm1.jpg" alt="">
					</section>
					<section style="text-align: left">
						<h3>Pengaturan memory fisik</h3>
						<div style="font-size: 0.7em">
							<p class="fragment">Pengalokasi halaman mengalokasikan dan membebaskan semua halaman fisik. Pengalokasi menggunakan algoritma buddy - heap untuk menjaga alur dari halaman fisik yang tersedia. </p>
							<p class="fragment">Berikut rincian algoritma dari Buddy Heap :</p>
							<ol class="fragment">
								<li>Setiap daerah memory yang dapat dialokasikan dipasangkan dengan daerah memory yang bersebelahan.</li>
								<li>Setiap dua alokasi partner memory dibebaskan, keduanya membentuk daerah yang lebih besar.</li>
								<li>Jika suatu permintaan memory kecil tidak dapat dipenuhi melalui alokasi memory bebas tersebut(yang berukuran sama) maka daerah memori bebas yang lebih besar dibagi menjadi 2 bagian untuk memenuhi permintaan</li>
							</ol>
						</div>
					</section>
					<section>
						<img src="img/linux/mm2.jpg" alt="">
					</section>
					<section style="text-align: left">
						<h3>Virtual Memory</h3>
						<p class="fragment" style="font-size: 0.7em">Sistem virtual memory pada Linux mengurusi ruang alamat yang tampak pada setiap proses. Sistem tersebut membuat halaman dari virtual memory sesuai permintaan dan mengatur pemuatan dari halaman tersebut dari disk atau menukarkannya keluar dari disk sebagaimana yang diperlukan.</p>
						<p class="fragment" style="font-size: 0.7em">Pengelola virtual memory mengurusi dua view terpisah ruang alamat yang diproses, yaitu:</p>
						<ul class="fragment" style="font-size: 0.7em">
							<li>Logical view yang mendeskripsikan instruksi yang menyangkut susunan dari ruang alamat.</li>
							<li>Physical view dari setiap ruang alamat yang disimpan pada tabel halaman hardware untuk suatu proses.</li>
						</ul>
					</section>
					<section style="text-align: left">
						<h3>Excecuting and Loading User Program</h3>
						<p class="fragment" style="font-size: 0.7em">Linux mengurusi tabel dari fungsi untuk pemuatan program. Registrasi dari pemuat ganda yang rutin mengijinkan Linux untuk mendukung ELF dan a.out format biner. Pada awalnya halaman file biner dipetakan ke dalam virtual memory. Sebuat ELF yang berformat file biner terdiri dari header diikuti beberapa bagian halaman berbaris.</p>
						</ul>
					</section>
					<section>
						<img src="img/linux/mm3.jpg" alt="">
					</section>
				</section>

				<!-- File Systems -->
				<section>
					<section>
						<h1>File Systems</h1>
					</section>
					<section>
						<img src="img/linux/fs1.jpg" alt="">
					</section>
					<section>
						<p>Setiap file sistem yang didukung oleh Linux memiliki fungsinya tersendiri untuk tiap operasi file yang didukung Linux.</p>
						<p class="fragment">Virtual File System akan memanggil fungsi yang sesuai dengan file sistem yang digunakan.</p>
					</section>
					<section>
						<img src="img/linux/fs2.jpg" alt="">
					</section>
					<section style="text-align: left">
						<h3>Implementasi</h3>
						<div style="font-size: 0.7em">
							<div class="fragment">
								<p>Superblock Object</p>
								<ul>
									<li><b>Deskripsi general</b> tentang file system itu sendiri</li>
									<li><b><i>Pointer</i></b> ke root dari file system tersebut</li>
									<li>Daftar dari file yang saat ini sedang <b>terbuka</b></li>
									<li>Daftar operasi yang dapat dilakukan pada <b><i>superblock</i></b></li>
								</ul>
							</div>
							<div class="fragment">
								<p>Inode Object</p>
								<ul>
									<li>Mengandung <b>metadata</b> dari sebuah file</li>
									<li><b>Daftar operasi</b> yang diimplementasikan untuk file system tersebut, yang dapat digunakan oleh VFS</li>
								</ul>
							</div>
						</div>
					</section>
					<section style="text-align: left">
						<div style="font-size: 0.7em">
							<div>
								<p>Dentry Object</p>
								<ul>
									<li><b>Komponen</b> dalam alamat file</li>
									<li>Dalam file system Linux setiap Dentry Object yang ada terhubung menjadi sebuah <b>pohon</b>.</li>
									<li>Mengandung <b><i>Pointer</i></b> ke file yang diasosiasikan dengan Dentry Object</li>
								</ul>
							</div>
							<div class="fragment">
								<p>File Object</p>
								<ul>
									<li>Hanya tercipta ketika file <b>dibuka</b>, maka dihancurkan juga tiap file yang bersangkutan ditutup.</li>
									<li>Mengandung <b>daftar operasi</b> yang telah diimplementasikan untuk file system yang digunakan. Dapat dipanggil oleh VFS.</li>
								</ul>
							</div>
						</div>
					</section>
				</section>

				<!-- I/O -->
				<section>
					<section>
						<h1>I/O Devices</h1>
					</section>
					<section style="text-align: left">
						<h4>Block Devices</h4>
						<p style="font-size: 0.7em">atau yang sering disebut sebagai random access device 
							adalah alat yang menyimpan data dan menawarkan akses ke seluruh bagian secara acak. 
							Contoh block device adalah hard disk dan floppy disk. Dengan menggunakan hard disk, 
							kita dapat mengakses data yang tersimpan secara acak.</p>
					</section>
					<section style="text-align: left; font-size: 0.7em">
						<p>Setiap <i>block</i> merepresentasikan unit dimana kernel melakukan proses I/O. 
							Ketika sebuah block dibaca ke memori, maka akan disimpan ke dalam <b>buffer</b>. 
							Untuk membaca dan menulis konten buffer dari / ke driver block device, 
							digunakanlah <b>Request manager</b>.</p>
					</section>
					<section style="text-align: left">
						<h4>Character Devices</h4>
						<p style="font-size: 0.7em">secara garis besar, <i>character device driver</i> terdiri dari hampir semua <i>device driver</i> yang tidak menawarkan <i>random access</i> ke block-block data.</p>
						<p class="fragment" style="font-size: 0.7em">Kernel hampir tidak melakukan <i>preprocessing</i> pada <i>read</i> maupun <i>write request</i> pada <i>character device</i>. Jadi, langsung di-<i>passing</i> gitu aja, biar <i>device</i>-nya yang menangani <i>request</i> tersebut.</p>
						<p class="fragment" style="font-size: 0.7em">Tapi ada pengecualian bagi <i>character device</i> tertentu yang terhubung sama <i>terminal device</i>. Disini kernel punya standar <i>interface</i> yang diatur oleh <b style="color:rgb(46, 194, 194)">tty_struct</b>. Tiap struktur menangani aliran data dari <i>terminal</i> dan memasukkannya ke <b style="color: orange">line discipline.</b></p>
						<p class="fragment" style="font-size: 0.85em; color: orange">Apa itu line discipline?</p>
					</section>
					<section style="text-align: left">
						<p style="font-size: 0.7em"><b>Line Discipline</b> adalah sebuah interpreter bagi informasi dari terminal device. Cara kerjanya adalah dengan "menempelkan" aliran data dari terminal pada standard input dan output pada suatu proses, menyebabkan proses tersebut bisa berkomunikasi langsung dengan terminal user. Contohnya adalah <b style="color: orange">tty discipline</b>.</p>
					</section>
					<section style="text-align: left">
						<h4>Network Devices</h4>
						<p style="font-size: 0.7em">paling berbeda diantara yang lain. User tidak bisa secara langsung mentransfer data ke network device. Tetapi user harus berkomunikasi secara tidak langsung dengan cara membuka koneksi ke subsistem network pada kernel. Selanjutnya ini akan dibahas lebih lanjut di subbab <b>Network Structures</b>.</p>
					</section>
				</section>

				<!-- IPC -->
				<section>
					<section>
						<h1>Interprocess Communication</h1>
					</section>
					<section>
						<p>Linux menyediakan lingkungan untuk proses saling berkomunikasi seperti memberitahu proses lain bahwa suatu event muncul, 
							berjalan atau telah berhenti, atau mentransfer data dari satu proses ke proses lainnya.</p>
					</section>
					<section style="text-align: left">
						<h3>Synchronization and Signals</h3>
						<p style="font-size: 0.8em">Dalam komunikasi antar proses, Linux memberikan sebuah mekanisme standar menggunakan signal. Fungsi signal yaitu 
							menginformasikan bahwa suatu event telah terjadi kepada suatu proses. Suatu proses (termasuk kernel) 
							dapat mengirimkan signal kepada proses lain, dengan syarat sinyal yang dikirim dimiliki pengguna yang berbeda. </p>
					</section>
					<section style="text-align: left">
						<p style="font-size: 0.8em">Secara internal, kernel tidak menggunakan signal dalam berkomunikasi, melainkan proses yang berjalan dalam mode kernel menggunakan scheduling states dan struktur wait_queue. Saat proses yang sedang berjalan dalam mode kernel menunggu suatu event sampai selesai, proses tersebut dimasukkan ke dalam wait queue event tersebut. Saat event yang dimaksud selesai, semua proses yang berada didalam queue dibangunkan sehingga memperbolehkan banyak proses untuk menunggu suatu event yang sama.</p>
					</section>
					<section style="text-align: left">
						<p style="font-size: 0.8em">Selain itu, cara lain yang diimplementasikan dalam Linux adalah semaphore. Semaphore adalah variabel yang mengontrol  akses suatu storage kepada banyak proses. Proses wait_queue pada kernel secara internal menggunakan implementasi semaphore.</p>
					</section>
					<section>
						<h3>Passing Data among Processes</h3>
						<p style="font-size: 0.8em; color: aqua;">Dalam Linux, melakukan passing data kepada proses lain dilakukan dengan beberapa mekanisme, diantaranya :</p>
					</section>
					<section style="text-align: left;">
						<h3>Pipe</h3>
						<img src="img/linux/ipc1.jpg" alt="">
						<p style="font-size: 0.65em">Sebuah child process diberikan akses yaitu Pipe kepada parent process untuk melakukan write/read data. Data yang di write pada satu sisi bisa di read di sisi lainnya.</p>
					</section>
					<section style="text-align: left;">
						<h3>Shared Memory</h3>
						<img src="img/linux/ipc2.jpg" alt="">
						<p style="font-size: 0.65em">Shared Memory merupakan memori tambahan yang ditambahkan pada address space 
							pemiliknya untuk digunakan sehingga proses - proses yang terkait dapat mengaksesnya karena memiliki segmen memori yang sama.
							</p>
					</section>
				</section>

				<!-- Network Structure -->
				<section>
					<section>
						<h1>Network Structure</h1>
						<p class="fragment" style="font-size: 0.7em">Secara internal, networking pada Linux dibagi menjadi 3 layer, yaitu:</p>
					</section>
					<section>
						<img src="img/linux/ns1.jpg" alt="">
					</section>
				</section>

				<!-- Security -->
				<section>
					<section>
						<h1>Security</h1>
					</section>
					<section style="text-align: left">
						<h3>Dibagi menjadi 2</h3>
						<br>
						<span class="fragment">
							<b>Authentication</b> -> memastikan bahwa hanya orang-orang yang mempunyai
							hak yang bisa mengakses sistem
						</span>
						<br><br>
						<span class="fragment">
								<b>Access Control</b> -> Mekanisme yang mengatur apakah suatu 
								user punya hak untuk mengakses suatu file
						</span>
					</section>
					<section>
						<q style="text-align: left; font-size: 0.8em">Biasanya diimplementasi dengan menggunakan <i>password</i> + <b>salt value</b> yang dimasukkan ke <i>one-way function</i>. 
							Salt value adalah sebuah random string yang di <i>concat</i> dengan passwordnya. Misal password: <b>love123 salt</b> = <b>14ksL!</b> 
							Maka akan menjadi <b>love12314ksL!</b> Kombinasi tersebut dimasukkan ke <i>one-way function</i>, 
							yang berarti hasil dari fungsi hashing tersebut tidak dapat di decode kembali.
						</q>
						<br><br>
						<h3 style="text-align: right">Authentication</h3>
						<p style="font-size: 0.7em; text-align: right"><i>Adylan, 1990</i></p>
					</section>
					<section>
						<p><b>PAM</b> (Pluggable Authentication Module)</p>
						<p>Sebuah shared library untuk sistem-sistem yang membutuhkan autentikasi user. (more on this later)</p>
					</section>
					<section>
						<h3>Access Control</h3>
						<div style="display: flex; font-size: 2.5em; color: aqua">
							<p class="fragment">UserID (uid)</p>
							<p class="fragment">GroupID (gid)</p>
						</div>
					</section>
					<section>
						<div style="display: flex; text-align: center">
							<img style="width: 35%; height: 100%; margin: 20px" src="img/linux/sec1.jpg" alt="">
							<img style="width: 50%; height: 100%; margin: 20px" src="img/linux/sec2.jpg" alt="">
						</div>
					</section>
					<section>
						<h4 style="color: aqua">1 UID, banyak GID</h4>
						<p>Semua objek pada Linux memiliki sebuah UID dan GID</p>
						<p style="font-size: 0.65em">Apabila UID pengakses cocok dengan UID objek, maka pengakses punya user rights.</p>
						<p style="font-size: 0.65em">Apabila GID pengakses cocok dengan GID objek, maka pengakses punya group rights.</p>
					</section>
					<section>
						<h3 style="color: red">MELTDOWN SPECTRE</h3>
						<img src="img/linux/sec3.jpg" class="fragment" alt="">
					</section>
					<section>
						<h3 style="color: rgb(0, 214, 71)">Address Space Layout Randomization (ASLR) </h3>
						<div style="font-size: 0.7em">
							<p class="fragment" >Dulu hacker biasanya melakukan serangan dengan mengetahui atau menebak lokasi address space 
								sehingga bisa melakukan penyalahgunaan dari sana.</p>
							<p class="fragment">Address space layout randomization mencegah itu semua dengan melakukan pengacakan address space 
								sehingga hacker sulit untuk mengetahui address space untuk melakukan serangan</p>								
						</div>
					</section>
				</section>
			</div>
		</div>
		<!-- <span id="open-menu" onclick="openNav()">&#9776; open</span> -->
		<div id="myNav" class="overlay-menu">
			<a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>
			<div class="overlay-menu-content">
				<a href="#/1">History of Linux</a>
				<a href="#/2">Design Principles</a>
				<a href="#/3">Kernel Modules</a>
				<a href="#/4">Process Management</a>
				<a href="#/5">Scheduling</a>
				<a href="#/6">Memory Management</a>
				<a href="#/7">File Systems</a>
				<a href="#/8">I/O Devices</a>
				<a href="#/9">IPC</a>
				<a href="#/10">Network Structures</a>
				<a href="#/11">Security</a>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,
				transition: 'slide',
				dependencies: [
				{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});

			function openNav() {
    			document.getElementById("myNav").style.width = "100%";
			}

			function closeNav() {
				document.getElementById("myNav").style.width = "0%";
			}
		</script>
	</body>
</html>
